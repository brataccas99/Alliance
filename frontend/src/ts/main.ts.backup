/**
 * Main TypeScript file for Alliance PNRR Futura Dashboard
 */

interface AnnouncementRow extends HTMLTableRowElement {
  dataset: DOMStringMap & {
    id: string;
    date: string;
    title: string;
    school: string;
    schoolId: string;
    city: string;
    category: string;
    status: string;
    highlight: string;
    summary: string;
    year: string;
    search: string;
    sort?: string;
    filter?: string;
  };
}

type SortKey = "title" | "school" | "city" | "category" | "date" | "status";
type SortDirection = "asc" | "desc";
type FilterType = "none" | "highlight" | "open" | "pnrr" | "pon" | "recent";

interface SortState {
  key: SortKey;
  direction: SortDirection;
}

type PersonalState = "none" | "read" | "applied" | "skip";

interface FilterPreset {
  id: string;
  name: string;
  searchTerm: string;
  schoolFilter: string;
  activeFilter: FilterType;
  dateFrom: string;
  dateTo: string;
  createdAt: string;
}

interface RecentAnnouncement {
  id: string;
  title: string;
  school: string;
  viewedAt: string;
}

const STATE_STORAGE_KEY = "alliance_ann_states";
const PRESETS_STORAGE_KEY = "alliance_filter_presets";
const RECENT_STORAGE_KEY = "alliance_recent_viewed";

function loadStates(): Record<string, PersonalState> {
  try {
    const raw = localStorage.getItem(STATE_STORAGE_KEY);
    if (!raw) return {};
    return JSON.parse(raw) as Record<string, PersonalState>;
  } catch {
    return {};
  }
}

function saveStates(states: Record<string, PersonalState>): void {
  try {
    localStorage.setItem(STATE_STORAGE_KEY, JSON.stringify(states));
  } catch {
    /* ignore */
  }
}

function loadPresets(): FilterPreset[] {
  try {
    const raw = localStorage.getItem(PRESETS_STORAGE_KEY);
    if (!raw) return [];
    return JSON.parse(raw) as FilterPreset[];
  } catch {
    return [];
  }
}

function savePresets(presets: FilterPreset[]): void {
  try {
    localStorage.setItem(PRESETS_STORAGE_KEY, JSON.stringify(presets));
  } catch {
    /* ignore */
  }
}

function loadRecentlyViewed(): RecentAnnouncement[] {
  try {
    const raw = localStorage.getItem(RECENT_STORAGE_KEY);
    if (!raw) return [];
    return JSON.parse(raw) as RecentAnnouncement[];
  } catch {
    return [];
  }
}

function saveRecentlyViewed(recent: RecentAnnouncement[]): void {
  try {
    localStorage.setItem(RECENT_STORAGE_KEY, JSON.stringify(recent));
  } catch {
    /* ignore */
  }
}

function addRecentlyViewed(id: string, title: string, school: string): void {
  const recent = loadRecentlyViewed();
  // Remove if already exists
  const filtered = recent.filter((r) => r.id !== id);
  // Add to beginning
  filtered.unshift({ id, title, school, viewedAt: new Date().toISOString() });
  // Keep only last 10
  const trimmed = filtered.slice(0, 10);
  saveRecentlyViewed(trimmed);
}

/**
 * Parse date string to timestamp
 */
function parseDate(value: string): number {
  const parsed = Date.parse(value);
  return Number.isNaN(parsed) ? 0 : parsed;
}

/**
 * Check if row matches active filter
 */
function matchesFilter(
  row: AnnouncementRow,
  activeFilter: FilterType,
  schoolFilter: string,
  yearFilter: string,
  dateFrom: string,
  dateTo: string
): boolean {
  if (activeFilter === "highlight" && row.dataset.highlight !== "true") {
    return false;
  }
  if (activeFilter === "open" && row.dataset.status?.toLowerCase() !== "open") {
    return false;
  }
  const categoryVal = row.dataset.category?.toLowerCase() || "";
  const summaryVal = row.dataset.summary?.toLowerCase() || "";
  const titleVal = row.dataset.title?.toLowerCase() || "";

  if (activeFilter === "pnrr") {
    const hasPNRR = categoryVal.includes("pnrr") ||
                    summaryVal.includes("pnrr") ||
                    titleVal.includes("pnrr");
    if (!hasPNRR) return false;
  }

  if (activeFilter === "pon") {
    const hasPON = categoryVal.includes("pon") ||
                   summaryVal.includes("pon") ||
                   titleVal.includes("pon") ||
                   summaryVal.includes("programma operativo nazionale");
    if (!hasPON) return false;
  }
  if (activeFilter === "recent") {
    const rowDate = parseDate(row.dataset.date || "");
    if (rowDate === 0) return false; // Skip if no valid date
    const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
    if (rowDate < sevenDaysAgo) return false;
  }
  if (schoolFilter && row.dataset.schoolId !== schoolFilter) {
    return false;
  }

  // Year filtering
  if (yearFilter && row.dataset.year !== yearFilter) {
    return false;
  }

  // Date range filtering
  if (dateFrom || dateTo) {
    const rowDate = parseDate(row.dataset.date || "");
    if (rowDate === 0) return false; // Skip if no valid date

    if (dateFrom) {
      const fromTimestamp = parseDate(dateFrom);
      if (rowDate < fromTimestamp) return false;
    }

    if (dateTo) {
      const toTimestamp = parseDate(dateTo);
      // Add 1 day to include the end date fully
      if (rowDate > toTimestamp + 86400000) return false;
    }
  }

  return true;
}

/**
 * Check if row matches search term
 */
function matchesSearch(row: AnnouncementRow, term: string): boolean {
  if (!term) return true;
  const haystack = row.dataset.search?.toLowerCase() || "";
  return haystack.includes(term);
}

/**
 * Update visibility of table rows based on filters and search
 */
function updateVisibility(
  rows: AnnouncementRow[],
  activeFilter: FilterType,
  schoolFilter: string,
  yearFilter: string,
  searchTerm: string,
  resultCounter: HTMLElement,
  dateFrom: string = "",
  dateTo: string = ""
): void {
  let visible = 0;
  rows.forEach((row) => {
    const show = matchesFilter(row, activeFilter, schoolFilter, yearFilter, dateFrom, dateTo) && matchesSearch(row, searchTerm);
    row.style.display = show ? "table-row" : "none";
    if (show) visible += 1;
  });
  resultCounter.textContent = `${visible} record`;
}

/**
 * Sort table rows by specified key
 */
function sortRows(
  key: SortKey,
  rows: AnnouncementRow[],
  tbody: HTMLTableSectionElement,
  headers: NodeListOf<HTMLTableCellElement>,
  currentSort: SortState,
  activeFilter: FilterType,
  schoolFilter: string,
  yearFilter: string,
  searchTerm: string,
  resultCounter: HTMLElement,
  dateFrom: string = "",
  dateTo: string = ""
): SortState {
  const direction: SortDirection =
    currentSort.key === key && currentSort.direction === "asc" ? "desc" : "asc";
  const newSort: SortState = { key, direction };

  const multiplier = direction === "asc" ? 1 : -1;

  rows.sort((a, b) => {
    const aVal = a.dataset[key] || "";
    const bVal = b.dataset[key] || "";

    if (key === "date") {
      return (parseDate(aVal) - parseDate(bVal)) * multiplier;
    }

    return aVal.toLowerCase().localeCompare(bVal.toLowerCase()) * multiplier;
  });

  rows.forEach((row) => tbody.appendChild(row));

  headers.forEach((h) => {
    const sortKey = h.dataset.sort as SortKey;
    h.classList.toggle("active", sortKey === key);
  });

  updateVisibility(rows, activeFilter, schoolFilter, yearFilter, searchTerm, resultCounter, dateFrom, dateTo);

  return newSort;
}

/**
 * Initialize the dashboard
 */
function initDashboard(): void {
  const table = document.getElementById("annTable") as HTMLTableElement | null;
  if (!table) return;

  const tbody = table.querySelector("tbody") as HTMLTableSectionElement | null;
  if (!tbody) return;

  const headers = table.querySelectorAll<HTMLTableCellElement>("th[data-sort]");
  const searchInput = document.getElementById("searchInput") as HTMLInputElement | null;
  const schoolSelect = document.getElementById("schoolFilter") as HTMLSelectElement | null;
  const yearSelect = document.getElementById("yearFilter") as HTMLSelectElement | null;
  const resultCounter = document.getElementById("resultsCount") as HTMLElement | null;
  const chipButtons = Array.from(
    document.querySelectorAll<HTMLButtonElement>(".chip")
  );
  const personalStates = loadStates();

  if (!searchInput || !resultCounter) return;

  let rows = Array.from(
    tbody.querySelectorAll<AnnouncementRow>("tr")
  ) as AnnouncementRow[];
  let activeFilter: FilterType = "none";
  let schoolFilter = "";
  let yearFilter = "";
  let currentSort: SortState = { key: "date", direction: "desc" };

  // Date range filter elements
  const dateFromInput = document.getElementById("dateFrom") as HTMLInputElement | null;
  const dateToInput = document.getElementById("dateTo") as HTMLInputElement | null;
  const clearDatesBtn = document.getElementById("clearDatesBtn");
  let dateFrom = "";
  let dateTo = "";

  // Preset elements
  const savePresetBtn = document.getElementById("savePresetBtn");
  const presetsList = document.getElementById("presetsList");

  // Recently viewed elements
  const recentlyViewedList = document.getElementById("recentlyViewedList");
  const clearRecentBtn = document.getElementById("clearRecentBtn");

  const applyState = (row: AnnouncementRow, newState: PersonalState) => {
    const annId = row.dataset.id || "";
    personalStates[annId] = newState;
    saveStates(personalStates);
    const pill = row.querySelector<HTMLElement>(".state-pill");
    const select = row.querySelector<HTMLSelectElement>(".state-select");
    if (select) {
      select.value = newState;
    }
    if (pill) {
      if (newState === "none") {
        pill.textContent = "";
        pill.style.display = "none";
      } else {
        const labels: Record<PersonalState, string> = {
          none: "",
          read: "Letto",
          applied: "Candidatura inviata",
          skip: "Non rilevante",
        };
        pill.textContent = labels[newState];
        pill.style.display = "inline-block";
      }
    }
  };

  // Render saved presets
  const renderPresets = () => {
    if (!presetsList) return;
    const presets = loadPresets();

    if (presets.length === 0) {
      presetsList.innerHTML = '<p class="empty-message">Nessun filtro salvato. Configura i filtri e clicca "Salva filtri".</p>';
      return;
    }

    presetsList.innerHTML = presets.map((preset) => `
      <div class="preset-item" data-preset-id="${preset.id}">
        <div class="preset-info">
          <strong class="preset-name">${preset.name}</strong>
          <span class="preset-details">${formatPresetDetails(preset)}</span>
        </div>
        <div class="preset-actions">
          <button class="action-btn small apply-preset" data-preset-id="${preset.id}" title="Applica filtro">
            ✓ Applica
          </button>
          <button class="action-btn small delete-preset" data-preset-id="${preset.id}" title="Elimina">
            ✕
          </button>
        </div>
      </div>
    `).join("");

    // Add event listeners
    presetsList.querySelectorAll<HTMLButtonElement>(".apply-preset").forEach((btn) => {
      btn.addEventListener("click", () => {
        const presetId = btn.dataset.presetId;
        if (presetId) applyPreset(presetId);
      });
    });

    presetsList.querySelectorAll<HTMLButtonElement>(".delete-preset").forEach((btn) => {
      btn.addEventListener("click", () => {
        const presetId = btn.dataset.presetId;
        if (presetId) deletePreset(presetId);
      });
    });
  };

  const formatPresetDetails = (preset: FilterPreset): string => {
    const parts: string[] = [];
    if (preset.searchTerm) parts.push(`"${preset.searchTerm}"`);
    if (preset.schoolFilter) parts.push("Scuola");
    if (preset.activeFilter !== "none") parts.push(preset.activeFilter);
    if (preset.dateFrom || preset.dateTo) parts.push("Date");
    return parts.join(" · ") || "Nessun filtro";
  };

  const applyPreset = (presetId: string) => {
    const presets = loadPresets();
    const preset = presets.find((p) => p.id === presetId);
    if (!preset) return;

    // Apply all filters
    if (searchInput) searchInput.value = preset.searchTerm;
    if (schoolSelect) schoolSelect.value = preset.schoolFilter;
    if (dateFromInput) dateFromInput.value = preset.dateFrom;
    if (dateToInput) dateToInput.value = preset.dateTo;

    dateFrom = preset.dateFrom;
    dateTo = preset.dateTo;
    schoolFilter = preset.schoolFilter;
    activeFilter = preset.activeFilter;

    // Update chip buttons
    chipButtons.forEach((chip) => {
      chip.classList.toggle("active", chip.dataset.filter === preset.activeFilter);
    });

    updateVisibility(rows, activeFilter, schoolFilter, preset.searchTerm, resultCounter, dateFrom, dateTo);
  };

  const deletePreset = (presetId: string) => {
    const presets = loadPresets();
    const filtered = presets.filter((p) => p.id !== presetId);
    savePresets(filtered);
    renderPresets();
  };

  // Render recently viewed
  const renderRecentlyViewed = () => {
    if (!recentlyViewedList) return;
    const recent = loadRecentlyViewed();

    if (recent.length === 0) {
      recentlyViewedList.innerHTML = '<p class="empty-message">Nessun annuncio visualizzato di recente.</p>';
      return;
    }

    recentlyViewedList.innerHTML = recent.map((item) => `
      <a href="/announcement/${item.id}" class="recent-item">
        <div class="recent-info">
          <strong class="recent-title">${item.title}</strong>
          <span class="recent-school">${item.school}</span>
        </div>
        <span class="recent-time">${formatTimeAgo(item.viewedAt)}</span>
      </a>
    `).join("");
  };

  const formatTimeAgo = (isoString: string): string => {
    const now = new Date().getTime();
    const then = new Date(isoString).getTime();
    const diffMs = now - then;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    if (diffMins < 1) return "Ora";
    if (diffMins < 60) return `${diffMins}m fa`;
    if (diffHours < 24) return `${diffHours}h fa`;
    if (diffDays < 7) return `${diffDays}g fa`;
    return new Date(isoString).toLocaleDateString();
  };

  // Initialize personal state UI per row
  rows.forEach((row) => {
    const annId = row.dataset.id || "";
    const select = row.querySelector<HTMLSelectElement>(".state-select");
    const link = row.querySelector<HTMLAnchorElement>(".detail-link");
    const currentState = personalStates[annId] || "none";
    applyState(row, currentState);

    if (select) {
      select.addEventListener("change", () => {
        applyState(row, select.value as PersonalState);
      });
    }

    if (link) {
      link.addEventListener("click", () => {
        applyState(row, "read");
        // Track in recently viewed
        const title = row.dataset.title || "";
        const school = row.dataset.school || "";
        addRecentlyViewed(annId, title, school);
        renderRecentlyViewed();
      });
    }
  });

  // Header click handlers for sorting
  headers.forEach((header) => {
    header.addEventListener("click", () => {
      const sortKey = header.dataset.sort as SortKey;
      if (sortKey) {
        currentSort = sortRows(
          sortKey,
          rows,
          tbody,
          headers,
          currentSort,
          activeFilter,
          schoolFilter,
          searchInput.value.trim().toLowerCase(),
          resultCounter,
          dateFrom,
          dateTo
        );
      }
    });
  });

  // Chip filter handlers
  chipButtons.forEach((chip) => {
    chip.addEventListener("click", () => {
      chipButtons.forEach((c) => c.classList.remove("active"));
      chip.classList.add("active");
      activeFilter = chip.dataset.filter as FilterType;
      updateVisibility(
        rows,
        activeFilter,
        schoolFilter,
        searchInput.value.trim().toLowerCase(),
        resultCounter,
        dateFrom,
        dateTo
      );
    });
  });

  // School select filter
  if (schoolSelect) {
    schoolSelect.addEventListener("change", () => {
      schoolFilter = schoolSelect.value;
      updateVisibility(
        rows,
        activeFilter,
        schoolFilter,
        searchInput.value.trim().toLowerCase(),
        resultCounter,
        dateFrom,
        dateTo
      );
    });
  }

  // Date range filter handlers
  if (dateFromInput) {
    dateFromInput.addEventListener("change", () => {
      dateFrom = dateFromInput.value;
      updateVisibility(rows, activeFilter, schoolFilter, searchInput.value.trim().toLowerCase(), resultCounter, dateFrom, dateTo);
    });
  }

  if (dateToInput) {
    dateToInput.addEventListener("change", () => {
      dateTo = dateToInput.value;
      updateVisibility(rows, activeFilter, schoolFilter, searchInput.value.trim().toLowerCase(), resultCounter, dateFrom, dateTo);
    });
  }

  if (clearDatesBtn) {
    clearDatesBtn.addEventListener("click", () => {
      if (dateFromInput) dateFromInput.value = "";
      if (dateToInput) dateToInput.value = "";
      dateFrom = "";
      dateTo = "";
      updateVisibility(rows, activeFilter, schoolFilter, searchInput.value.trim().toLowerCase(), resultCounter, dateFrom, dateTo);
    });
  }

  // Save preset handler
  if (savePresetBtn) {
    savePresetBtn.addEventListener("click", () => {
      const name = prompt("Nome del filtro:");
      if (!name) return;

      const preset: FilterPreset = {
        id: Date.now().toString(),
        name,
        searchTerm: searchInput.value,
        schoolFilter,
        activeFilter,
        dateFrom,
        dateTo,
        createdAt: new Date().toISOString(),
      };

      const presets = loadPresets();
      presets.unshift(preset);
      savePresets(presets);
      renderPresets();
    });
  }

  // Clear recently viewed handler
  if (clearRecentBtn) {
    clearRecentBtn.addEventListener("click", () => {
      if (confirm("Cancellare la cronologia visualizzazioni?")) {
        saveRecentlyViewed([]);
        renderRecentlyViewed();
      }
    });
  }

  // Search input handler
  searchInput.addEventListener("input", () => {
    const term = searchInput.value.trim().toLowerCase();
    updateVisibility(rows, activeFilter, schoolFilter, term, resultCounter, dateFrom, dateTo);
  });

  // View toggle handlers
  const viewButtons = document.querySelectorAll<HTMLButtonElement>(".view-btn");
  const tableView = document.getElementById("annTable") as HTMLElement | null;
  const cardView = document.getElementById("cardView") as HTMLElement | null;

  viewButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const view = btn.dataset.view;

      // Update active state
      viewButtons.forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");

      // Toggle views
      if (view === "table") {
        if (tableView) tableView.style.display = "table";
        if (cardView) cardView.style.display = "none";
      } else if (view === "cards") {
        if (tableView) tableView.style.display = "none";
        if (cardView) cardView.style.display = "grid";

        // Apply same filters to cards
        const cards = cardView?.querySelectorAll<HTMLElement>(".announcement-card");
        cards?.forEach((card) => {
          const cardRow = card as any;
          const show = matchesFilter(cardRow, activeFilter, schoolFilter, dateFrom, dateTo) && matchesSearch(cardRow, searchInput.value.trim().toLowerCase());
          card.style.display = show ? "block" : "none";
        });
      }
    });
  });

  // Clickable stat cards for quick filtering
  const statCards = document.querySelectorAll<HTMLElement>(".stat-card[data-quick-filter]");
  statCards.forEach((card) => {
    card.addEventListener("click", () => {
      const filterType = card.dataset.quickFilter as FilterType | "all";

      // Remove active from all stat cards
      statCards.forEach((c) => c.classList.remove("active"));
      card.classList.add("active");

      // Apply the corresponding filter
      chipButtons.forEach((c) => c.classList.remove("active"));

      if (filterType === "all") {
        chipButtons[0]?.classList.add("active");
        activeFilter = "none";
      } else if (filterType === "highlight") {
        chipButtons[1]?.classList.add("active");
        activeFilter = "highlight";
      } else if (filterType === "open") {
        chipButtons[2]?.classList.add("active");
        activeFilter = "open";
      } else if (filterType === "pnrr") {
        chipButtons[3]?.classList.add("active");
        activeFilter = "pnrr";
      } else if (filterType === "pon") {
        chipButtons[4]?.classList.add("active");
        activeFilter = "pon";
      } else if (filterType === "recent") {
        chipButtons[5]?.classList.add("active");
        activeFilter = "recent";
      }

      updateVisibility(rows, activeFilter, schoolFilter, searchInput.value.trim().toLowerCase(), resultCounter, dateFrom, dateTo);
    });
  });

  // Export to CSV functionality
  const exportBtn = document.getElementById("exportBtn");
  const fetchBtn = document.getElementById("fetchBtn");
  const fetchStatus = document.getElementById("fetchStatus");
  const fetchProgressBar = document.getElementById("fetchProgressBar") as HTMLElement | null;
  const fetchProgressText = document.getElementById("fetchProgressText");
  const fetchCurrentSchool = document.getElementById("fetchCurrentSchool");
  let fetchPoll: number | null = null;

  const startFetchPolling = () => {
    if (!fetchStatus) return;
    fetchStatus.style.display = "block";
    const poll = async () => {
      try {
        const res = await fetch("/api/fetch/status");
        const data = await res.json();
        const total = Number(data.total || 0);
        const current = Number(data.current || 0);
        const school = data.school || "";
        const status = data.status || "idle";
        const pct = total > 0 ? Math.min(100, Math.round((current / total) * 100)) : 0;
        if (fetchProgressBar) {
          fetchProgressBar.style.width = `${pct}%`;
        }
        if (fetchProgressText) {
          fetchProgressText.textContent = total > 0 ? `${current}/${total} (${pct}%)` : "";
        }
        if (fetchCurrentSchool) {
          fetchCurrentSchool.textContent = school;
        }
        if (status === "idle" || status === "done") {
          if (fetchStatus) fetchStatus.style.display = "none";
          if (fetchPoll !== null) {
            clearInterval(fetchPoll);
            fetchPoll = null;
          }
        }
      } catch (e) {
        console.error("Polling fetch status failed", e);
      }
    };
    poll();
    fetchPoll = window.setInterval(poll, 2000);
  };

  if (fetchBtn) {
    fetchBtn.addEventListener("click", async () => {
      fetchBtn.setAttribute("disabled", "true");
      fetchBtn.textContent = "Aggiorno...";
      startFetchPolling();
      try {
        await fetch("/api/fetch", { method: "POST" });
        location.reload();
      } catch (err) {
        alert("Errore durante il fetch");
        console.error(err);
      } finally {
        fetchBtn.removeAttribute("disabled");
        fetchBtn.textContent = "Aggiorna annunci";
        if (fetchPoll !== null) {
          clearInterval(fetchPoll);
          fetchPoll = null;
        }
      }
    });
  }

  if (exportBtn) {
    exportBtn.addEventListener("click", () => {
      const visibleRows = rows.filter((row) => row.style.display !== "none");
      const csvData: string[][] = [
        ["ID", "Titolo", "Scuola", "Città", "Categoria", "Data", "Stato", "Link"]
      ];

      visibleRows.forEach((row) => {
        const id = row.dataset.id || "";
        const title = row.dataset.title || "";
        const school = row.dataset.school || "";
        const city = row.dataset.city || "";
        const category = row.dataset.category || "";
        const date = row.dataset.date || "";
        const status = row.dataset.status || "";
        const link = row.querySelector<HTMLAnchorElement>(".detail-link")?.href || "";

        csvData.push([id, title, school, city, category, date, status, link]);
      });

      const csvContent = csvData.map((row) =>
        row.map((cell) => `"${cell.replace(/"/g, '""')}"`).join(",")
      ).join("\n");

      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = `annunci_${new Date().toISOString().split("T")[0]}.csv`;
      link.click();
    });
  }

  // Bulk selection handlers
  const selectAllCheckbox = document.getElementById("selectAllCheckbox") as HTMLInputElement | null;
  const rowCheckboxes = document.querySelectorAll<HTMLInputElement>(".row-checkbox");
  const selectAllBtn = document.getElementById("selectAllBtn");
  const deselectAllBtn = document.getElementById("deselectAllBtn");
  const selectedCount = document.getElementById("selectedCount");
  const bulkReadBtn = document.getElementById("bulkReadBtn") as HTMLButtonElement | null;
  const bulkSkipBtn = document.getElementById("bulkSkipBtn") as HTMLButtonElement | null;

  const updateBulkActions = () => {
    const checked = Array.from(rowCheckboxes).filter((cb) => cb.checked && cb.closest("tr")?.style.display !== "none");
    const count = checked.length;

    if (selectedCount) {
      selectedCount.querySelector("strong")!.textContent = count.toString();
      selectedCount.style.display = count > 0 ? "inline" : "none";
    }

    if (bulkReadBtn) bulkReadBtn.disabled = count === 0;
    if (bulkSkipBtn) bulkSkipBtn.disabled = count === 0;
  };

  if (selectAllCheckbox) {
    selectAllCheckbox.addEventListener("change", () => {
      const visibleCheckboxes = Array.from(rowCheckboxes).filter(
        (cb) => cb.closest("tr")?.style.display !== "none"
      );
      visibleCheckboxes.forEach((cb) => {
        cb.checked = selectAllCheckbox.checked;
      });
      updateBulkActions();
    });
  }

  rowCheckboxes.forEach((cb) => {
    cb.addEventListener("change", updateBulkActions);
  });

  if (selectAllBtn) {
    selectAllBtn.addEventListener("click", () => {
      const visibleCheckboxes = Array.from(rowCheckboxes).filter(
        (cb) => cb.closest("tr")?.style.display !== "none"
      );
      visibleCheckboxes.forEach((cb) => {
        cb.checked = true;
      });
      updateBulkActions();
    });
  }

  if (deselectAllBtn) {
    deselectAllBtn.addEventListener("click", () => {
      rowCheckboxes.forEach((cb) => {
        cb.checked = false;
      });
      updateBulkActions();
    });
  }

  // Bulk actions
  if (bulkReadBtn) {
    bulkReadBtn.addEventListener("click", () => {
      const checked = Array.from(rowCheckboxes).filter((cb) => cb.checked);
      checked.forEach((cb) => {
        const row = cb.closest("tr") as AnnouncementRow;
        if (row) {
          applyState(row, "read");
        }
      });
      rowCheckboxes.forEach((cb) => {
        cb.checked = false;
      });
      updateBulkActions();
    });
  }

  if (bulkSkipBtn) {
    bulkSkipBtn.addEventListener("click", () => {
      const checked = Array.from(rowCheckboxes).filter((cb) => cb.checked);
      checked.forEach((cb) => {
        const row = cb.closest("tr") as AnnouncementRow;
        if (row) {
          applyState(row, "skip");
        }
      });
      rowCheckboxes.forEach((cb) => {
        cb.checked = false;
      });
      updateBulkActions();
    });
  }

  // Keyboard shortcuts
  document.addEventListener("keydown", (e) => {
    // Ctrl/Cmd + K for search
    if ((e.ctrlKey || e.metaKey) && e.key === "k") {
      e.preventDefault();
      searchInput.focus();
      searchInput.select();
    }

    // Escape to clear search
    if (e.key === "Escape") {
      if (document.activeElement === searchInput) {
        searchInput.value = "";
        searchInput.blur();
        updateVisibility(rows, activeFilter, schoolFilter, "", resultCounter, dateFrom, dateTo);
      }
    }

    // Ctrl/Cmd + A to select all visible
    if ((e.ctrlKey || e.metaKey) && e.key === "a" && document.activeElement !== searchInput) {
      e.preventDefault();
      const visibleCheckboxes = Array.from(rowCheckboxes).filter(
        (cb) => cb.closest("tr")?.style.display !== "none"
      );
      visibleCheckboxes.forEach((cb) => {
        cb.checked = true;
      });
      updateBulkActions();
    }

    // Ctrl/Cmd + E to export
    if ((e.ctrlKey || e.metaKey) && e.key === "e") {
      e.preventDefault();
      exportBtn?.click();
    }
  });

  // Initialize: sort by date desc and apply default filter/search
  currentSort = sortRows(
    "date",
    rows,
    tbody,
    headers,
    currentSort,
    activeFilter,
    schoolFilter,
    "",
    resultCounter,
    dateFrom,
    dateTo
  );

  // Initialize presets and recently viewed
  renderPresets();
  renderRecentlyViewed();
}

// Initialize when DOM is ready
document.addEventListener("DOMContentLoaded", initDashboard);
